// Auto-generated by https://github.com/vladkens/apigen-ts
// Source: http://localhost:8000/openapi.json

type Headers = Record<string, string>;
export type ApigenHeaders =
  | Headers
  | ((method: string, path: string) => Headers | Promise<Headers>);

export interface ApigenConfig {
  baseUrl: string;
  headers: ApigenHeaders;
}

export interface ApigenRequest extends Omit<RequestInit, "body"> {
  search?: Record<string, unknown>;
  body?: unknown;
}

export class ApiClient {
  Config: ApigenConfig;

  constructor(config?: Partial<ApigenConfig>) {
    this.Config = { baseUrl: "/", headers: {}, ...config };
  }

  async ParseError(rep: Response) {
    try {
      return await rep.json();
    } catch (e) {
      throw rep;
    }
  }

  PrepareFetchUrl(path: string): URL {
    let base = this.Config.baseUrl;
    if ("location" in globalThis && (base === "" || base.startsWith("/"))) {
      const { location } = globalThis as unknown as {
        location: { origin: string };
      };
      base = `${location.origin}${base.endsWith("/") ? base : `/${base}`}`;
    }

    return new URL(path, base);
  }

  async Fetch<T>(
    method: string,
    path: string,
    opts: ApigenRequest = {},
  ): Promise<T> {
    const url = this.PrepareFetchUrl(path);

    for (const [k, v] of Object.entries(opts?.search ?? {})) {
      url.searchParams.append(
        k,
        Array.isArray(v) ? v.join(",") : (v as string),
      );
    }

    const configHeaders =
      typeof this.Config.headers === "function"
        ? await this.Config.headers(method, path)
        : this.Config.headers;

    const headers = new Headers({ ...configHeaders, ...opts.headers });
    const ct = headers.get("content-type") ?? "application/json";

    let body: FormData | URLSearchParams | string | undefined = undefined;

    if (
      ct === "multipart/form-data" ||
      ct === "application/x-www-form-urlencoded"
    ) {
      headers.delete("content-type");
      body =
        ct === "multipart/form-data" ? new FormData() : new URLSearchParams();
      for (const [k, v] of Object.entries(
        opts.body as Record<string, string>,
      )) {
        body.append(k, v);
      }
    }

    if (ct === "application/json" && typeof opts.body !== "string") {
      headers.set("content-type", "application/json");
      body = JSON.stringify(opts.body);
    }

    const credentials = opts.credentials ?? "include";
    const rep = await fetch(url.toString(), {
      method,
      ...opts,
      headers,
      body,
      credentials,
    });
    if (!rep.ok) throw await this.ParseError(rep);

    const rs = await rep.text();
    try {
      return JSON.parse(rs) as T;
    } catch (e) {
      return rs as unknown as T;
    }
  }

  items = {
    getAllItemsGet: () => {
      return this.Fetch<ItemResponseDTO[]>("get", "/items/", {});
    },

    createItemsPost: (body: Body_create_items__post) => {
      return this.Fetch<ItemResponseDTO>("post", "/items/", {
        body,
        headers: { "content-type": "multipart/form-data" },
      });
    },

    getByIdItemsItemIdGet: (item_id: string) => {
      return this.Fetch<ItemResponseDTO>("get", `/items/${item_id}`, {});
    },

    updateItemByIdItemsItemIdPut: (item_id: string, body: ItemUpdateDTO) => {
      return this.Fetch<ItemResponseDTO>("put", `/items/${item_id}`, { body });
    },

    deleteByIdItemsItemIdDelete: (item_id: string) => {
      return this.Fetch<void>("delete", `/items/${item_id}`, {});
    },
  };

  files = {
    getItemMediaMediaItemIdGet: (item_id: string) => {
      return this.Fetch<void>("get", `/media/${item_id}`, {});
    },

    updateItemMediaMediaItemIdPut: (
      item_id: string,
      body: Body_update_item_media_media__item_id__put,
    ) => {
      return this.Fetch<ItemResponseDTO>("put", `/media/${item_id}`, {
        body,
        headers: { "content-type": "multipart/form-data" },
      });
    },
  };
}

export type Body_create_items__post = {
  file: File;
  title: string;
  description: string;
  quantity: number;
  price: number;
  order?: number | null;
};

export type Body_update_item_media_media__item_id__put = {
  file: File;
};

export type HTTPValidationError = {
  detail?: ValidationError[];
};

export type ItemResponseDTO = {
  id: string;
  title: string;
  description: string;
  file_uri: string;
  file_mime_type: string;
  quantity: number;
  price: number;
  order: number;
};

export type ItemUpdateDTO = {
  title?: string | null;
  description?: string | null;
  quantity?: number | null;
  price?: number | null;
  order?: number | null;
};

export type ValidationError = {
  loc: (string | number)[];
  msg: string;
  type: string;
};
